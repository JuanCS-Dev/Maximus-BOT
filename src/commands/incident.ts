import {
  ChatInputCommandInteraction,
  SlashCommandBuilder,
  PermissionFlagsBits,
  ChannelType,
  TextChannel,
  EmbedBuilder,
} from 'discord.js';
import { prisma } from '../database/client';
import { logger } from '../utils/logger';

export const data = new SlashCommandBuilder()
  .setName('incident')
  .setDescription('Start an incident response playbook')
  .addStringOption((option) =>
    option
      .setName('type')
      .setDescription('Incident type')
      .setRequired(true)
      .addChoices(
        { name: 'Raid - Mass coordinated attack', value: 'raid' },
        { name: 'Phishing - Malicious URLs/scams', value: 'phishing' },
        { name: 'Malware - Malicious file distribution', value: 'malware' },
        { name: 'Doxxing - Personal information leak', value: 'doxxing' },
        { name: 'Toxicity - Severe harassment/abuse', value: 'toxicity' },
        { name: 'Other - General security incident', value: 'other' }
      )
  )
  .addStringOption((option) =>
    option
      .setName('severity')
      .setDescription('Incident severity')
      .setRequired(true)
      .addChoices(
        { name: 'Low - Minor impact', value: 'low' },
        { name: 'Medium - Moderate impact', value: 'medium' },
        { name: 'High - Significant impact', value: 'high' },
        { name: 'Critical - Severe/ongoing threat', value: 'critical' }
      )
  )
  .addStringOption((option) =>
    option
      .setName('description')
      .setDescription('Brief description of the incident')
      .setRequired(true)
      .setMaxLength(500)
  )
  .addUserOption((option) =>
    option
      .setName('suspect')
      .setDescription('Primary suspect (if known)')
      .setRequired(false)
  )
  .setDefaultMemberPermissions(PermissionFlagsBits.ModerateMembers)
  .setDMPermission(false);

export async function execute(
  interaction: ChatInputCommandInteraction
): Promise<void> {
  try {
    await interaction.deferReply({ ephemeral: true });

    const incidentType = interaction.options.getString('type', true);
    const severity = interaction.options.getString('severity', true);
    const description = interaction.options.getString('description', true);
    const suspect = interaction.options.getUser('suspect');

    logger.info(
      `Incident playbook started: ${incidentType} (${severity}) by ${interaction.user.tag}`
    );

    // 1. Create incident case in database
    const incidentCase = await prisma.incidentCase.create({
      data: {
        guildId: interaction.guildId!,
        incidentType,
        severity,
        status: 'open',
        channelId: '', // Will update after channel creation
        relatedThreats: [],
        timeline: {
          events: [
            {
              timestamp: new Date().toISOString(),
              action: 'incident_created',
              actor: interaction.user.tag,
              description: description,
            },
          ],
          description: description,
          reporter: interaction.user.tag,
          reporterId: interaction.user.id,
          suspect: suspect?.tag,
          suspectId: suspect?.id,
        },
      },
    });

    logger.info(`Incident case created: ${incidentCase.id}`);

    // 2. Create private IR channel
    const irChannel = await createIncidentChannel(
      interaction,
      incidentCase.id,
      incidentType,
      severity
    );

    if (!irChannel) {
      await interaction.editReply({
        content: '‚ùå Failed to create incident response channel',
      });
      return;
    }

    // 3. Update incident case with channel ID
    await prisma.incidentCase.update({
      where: { id: incidentCase.id },
      data: { channelId: irChannel.id },
    });

    // 4. Send initial message to IR channel
    await sendIncidentBriefing(irChannel, {
      caseId: incidentCase.id,
      type: incidentType,
      severity,
      description,
      reporter: interaction.user.tag,
      suspect: suspect?.tag,
    });

    // 5. Notify initiator
    await interaction.editReply({
      content: `‚úÖ Incident response playbook initiated!\n\n**Case ID:** \`${incidentCase.id}\`\n**IR Channel:** ${irChannel}\n**Status:** Open\n\nThe IR team has been notified.`,
    });

    logger.info(
      `Incident playbook complete: ${incidentCase.id} (channel: ${irChannel.id})`
    );
  } catch (error: unknown) {
    logger.error(`Error in /incident command:`, error);

    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error';

    await interaction.editReply({
      content: `‚ùå Failed to start incident playbook: ${errorMessage}`,
    });
  }
}

/**
 * Create private incident response channel
 */
async function createIncidentChannel(
  interaction: ChatInputCommandInteraction,
  caseId: string,
  incidentType: string,
  severity: string
): Promise<TextChannel | null> {
  try {
    const guild = interaction.guild;
    if (!guild) {
      return null;
    }

    // Get or create IR category
    let irCategory = guild.channels.cache.find(
      (c) =>
        c.type === ChannelType.GuildCategory &&
        c.name.toLowerCase().includes('incident')
    );

    if (!irCategory) {
      irCategory = await guild.channels.create({
        name: 'üö® Incident Response',
        type: ChannelType.GuildCategory,
        position: 0,
      });
    }

    // Create private channel for this incident
    const channelName = `ir-${caseId.substring(0, 8)}-${incidentType}`;

    const channel = await guild.channels.create({
      name: channelName,
      type: ChannelType.GuildText,
      parent: irCategory.id,
      topic: `üö® Incident Response | Case: ${caseId} | Severity: ${severity.toUpperCase()}`,
      permissionOverwrites: [
        {
          id: guild.id, // @everyone
          deny: [PermissionFlagsBits.ViewChannel],
        },
        {
          id: interaction.user.id, // Initiator
          allow: [
            PermissionFlagsBits.ViewChannel,
            PermissionFlagsBits.SendMessages,
            PermissionFlagsBits.ReadMessageHistory,
          ],
        },
        {
          id: guild.members.me!.id, // Bot
          allow: [
            PermissionFlagsBits.ViewChannel,
            PermissionFlagsBits.SendMessages,
            PermissionFlagsBits.ManageChannels,
          ],
        },
      ],
    });

    // Add moderators/admins to channel
    const moderators = guild.members.cache.filter(
      (m) =>
        m.permissions.has(PermissionFlagsBits.ModerateMembers) && !m.user.bot
    );

    for (const [, moderator] of moderators) {
      try {
        await channel.permissionOverwrites.create(moderator, {
          ViewChannel: true,
          SendMessages: true,
          ReadMessageHistory: true,
        });
      } catch (error: unknown) {
        logger.warn(
          `Failed to add moderator ${moderator.user.tag} to IR channel:`,
          error
        );
      }
    }

    logger.info(
      `IR channel created: ${channel.name} (${moderators.size} moderators added)`
    );

    return channel as TextChannel;
  } catch (error: unknown) {
    logger.error(`Error creating incident channel:`, error);
    return null;
  }
}

/**
 * Send initial incident briefing to IR channel
 */
async function sendIncidentBriefing(
  channel: TextChannel,
  incident: {
    caseId: string;
    type: string;
    severity: string;
    description: string;
    reporter: string;
    suspect?: string;
  }
): Promise<void> {
  try {
    const severityColor = getSeverityColor(incident.severity);
    const severityEmoji = getSeverityEmoji(incident.severity);

    const embed = new EmbedBuilder()
      .setTitle(
        `${severityEmoji} Incident Response Playbook - ${incident.type.toUpperCase()}`
      )
      .setColor(severityColor)
      .setDescription(incident.description)
      .addFields(
        {
          name: 'üìã Case Information',
          value: [
            `**Case ID:** \`${incident.caseId}\``,
            `**Type:** ${incident.type}`,
            `**Severity:** ${incident.severity.toUpperCase()}`,
            `**Reported By:** ${incident.reporter}`,
            `**Status:** üî¥ OPEN`,
          ].join('\n'),
        },
        {
          name: 'üéØ Initial Actions',
          value: [
            '1Ô∏è‚É£ Review incident details and evidence',
            '2Ô∏è‚É£ Identify affected users/channels',
            '3Ô∏è‚É£ Implement containment measures',
            '4Ô∏è‚É£ Document all actions taken',
            '5Ô∏è‚É£ Escalate if needed',
          ].join('\n'),
        }
      )
      .setTimestamp()
      .setFooter({ text: 'MAXIMUS Incident Response System' });

    if (incident.suspect) {
      embed.addFields({
        name: 'üë§ Primary Suspect',
        value: incident.suspect,
      });
    }

    await channel.send({
      content: `@here **Incident Response Team** - New ${incident.severity.toUpperCase()} severity incident`,
      embeds: [embed],
    });

    // Send playbook checklist
    const checklistEmbed = new EmbedBuilder()
      .setTitle('üìù Incident Response Checklist')
      .setColor(0x5865f2)
      .setDescription(getPlaybookChecklist(incident.type))
      .setFooter({
        text: 'Update this channel with your progress and findings',
      });

    await channel.send({ embeds: [checklistEmbed] });

    logger.info(`Incident briefing sent to channel: ${channel.id}`);
  } catch (error: unknown) {
    logger.error(`Error sending incident briefing:`, error);
  }
}

/**
 * Get incident-specific playbook checklist
 */
function getPlaybookChecklist(incidentType: string): string {
  const checklists: Record<string, string> = {
    raid: [
      '‚òê Enable verification level (VERY_HIGH)',
      '‚òê Kick recent suspicious members',
      '‚òê Lock down affected channels',
      '‚òê Review audit logs for patterns',
      '‚òê Ban confirmed raiders',
      '‚òê Document raid tactics/timing',
      '‚òê Report to Discord Trust & Safety',
    ].join('\n'),

    phishing: [
      '‚òê Delete all phishing messages',
      '‚òê Ban/timeout phishing accounts',
      '‚òê Warn members about the scam',
      '‚òê Report URLs to Google Safe Browsing',
      '‚òê Check for compromised accounts',
      '‚òê Update server rules/warnings',
      '‚òê Create MISP event for IOCs',
    ].join('\n'),

    malware: [
      '‚òê Delete malicious attachments',
      '‚òê Ban malware distributors',
      '‚òê Warn members not to download',
      '‚òê Submit samples to VirusTotal',
      '‚òê Create MISP event with hashes',
      '‚òê Scan for additional compromised accounts',
      '‚òê Update security policies',
    ].join('\n'),

    doxxing: [
      '‚òê Delete all doxxing content immediately',
      '‚òê Ban perpetrators permanently',
      '‚òê Contact affected victims',
      '‚òê Report to Discord Trust & Safety',
      '‚òê Document evidence (screenshots)',
      '‚òê Consider legal action',
      '‚òê Review channel permissions',
    ].join('\n'),

    toxicity: [
      '‚òê Timeout/ban offending users',
      '‚òê Delete toxic messages',
      '‚òê Check user history for patterns',
      '‚òê Warn community about behavior',
      '‚òê Review moderation policies',
      '‚òê Escalate if harassment continues',
      '‚òê Provide support to victims',
    ].join('\n'),

    other: [
      '‚òê Assess incident scope and impact',
      '‚òê Identify affected resources',
      '‚òê Implement containment measures',
      '‚òê Document evidence and timeline',
      '‚òê Execute response actions',
      '‚òê Monitor for escalation',
      '‚òê Create post-incident report',
    ].join('\n'),
  };

  return (
    checklists[incidentType] ||
    checklists.other
  );
}

/**
 * Get severity color
 */
function getSeverityColor(severity: string): number {
  switch (severity) {
    case 'critical':
      return 0x8b0000; // Dark red
    case 'high':
      return 0xff0000; // Red
    case 'medium':
      return 0xff8c00; // Orange
    case 'low':
      return 0xffff00; // Yellow
    default:
      return 0x5865f2; // Discord blue
  }
}

/**
 * Get severity emoji
 */
function getSeverityEmoji(severity: string): string {
  switch (severity) {
    case 'critical':
      return 'üî¥';
    case 'high':
      return 'üü†';
    case 'medium':
      return 'üü°';
    case 'low':
      return 'üü¢';
    default:
      return 'üîµ';
  }
}
